package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"log"
	"os"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	pkgName  string
	excludes string
)

const loadMode = packages.NeedName | packages.NeedSyntax

func main() {
	if err := execute(); err != nil {
		log.Fatal(err)
	}
}

type Package struct {
	Name    string
	StdName string

	Types     []string
	Constants []string
	Variables []string
	Functions []string
}

func execute() error {
	flag.StringVar(&pkgName, "pkg", "", "package name you want to extend")
	flag.StringVar(&excludes, "excludes", "", "const/var/func/type names you want to exclude, separated by comma")
	flag.Parse()

	excludes := strings.Split(excludes, ",")

	if pkgName == "" {
		return errors.New("-pkg option is required")
	}

	pkg := GetPackage(pkgName)
	if pkg == nil {
		return errors.New("-pkg option must be a standard package")
	}

	src, err := NewPackage(pkg, excludes).Source()

	if err != nil {
		return err
	}

	fmt.Print(src)

	return nil
}

func oneOf(e string, list []string) bool {
	for _, t := range list {
		if e == t {
			return true
		}
	}

	return false
}

func GetPackage(pkg string) *packages.Package {
	stds, err := packages.Load(&packages.Config{Mode: loadMode}, "std")
	if err != nil {
		panic(err)
	}

	for _, std := range stds {
		if strings.HasPrefix(std.PkgPath, "internal") || strings.HasPrefix(std.PkgPath, "vendor") {
			continue
		}

		if std.PkgPath == pkg {
			return std
		}
	}

	return nil
}

func NewPackage(base *packages.Package, excludes []string) Package {
	pkg := Package{
		Name:    base.Name,
		StdName: base.PkgPath,
	}

	for _, f := range base.Syntax {
		for _, decl := range f.Decls {
			switch decl := decl.(type) {
			case *ast.GenDecl:
				for _, spec := range decl.Specs {
					switch spec := spec.(type) {
					case *ast.TypeSpec:
						if !spec.Name.IsExported() || oneOf(spec.Name.Name, excludes) {
							continue
						}

						pkg.Types = append(pkg.Types, spec.Name.Name)
					case *ast.ValueSpec:
						var names []string

						for _, name := range spec.Names {
							if name.IsExported() && !oneOf(name.Name, excludes) {
								names = append(names, name.Name)
							}
						}

						switch decl.Tok {
						case token.CONST:
							pkg.Constants = append(pkg.Constants, names...)
						case token.VAR:
							pkg.Variables = append(pkg.Variables, names...)
						}
					}
				}
			case *ast.FuncDecl:
				if !decl.Name.IsExported() || decl.Recv != nil || oneOf(decl.Name.Name, excludes) {
					continue
				}

				pkg.Functions = append(pkg.Functions, decl.Name.Name)
			}
		}
	}

	return pkg
}

func (pkg Package) Source() (string, error) {
	var buf bytes.Buffer

	outf := func(format string, v ...interface{}) {
		fmt.Fprintf(&buf, format, v...)
	}

	outf("// Package %s wraps the standard %[1]s package to extend.", pkg.Name)
	outf("\n// Code generated by xstd. DO NOT EDIT.")
	outf("\npackage %s", pkg.Name)

	outf("\nimport %s", strconv.Quote(pkg.StdName))

	if len(pkg.Variables) > 0 {
		outf("\n\n// wrap std variables")
		outf("\n%s", pkg.printBlock("var", pkg.Variables))
	}

	if len(pkg.Constants) > 0 {
		outf("\n\n// wrap std constants")
		outf("\n%s", pkg.printBlock("const", pkg.Constants))
	}

	if len(pkg.Functions) > 0 {
		outf("\n\n// wrap std functions")
		outf("\n%s", pkg.printBlock("var", pkg.Functions))
	}

	if len(pkg.Types) > 0 {
		outf("\n\n// wrap std types")
		outf("\n%s", pkg.printBlock("type", pkg.Types))
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		buf.WriteTo(os.Stderr)
		return "", err
	}

	return string(src), nil
}

func (pkg Package) printBlock(typ string, list []string) string {
	var buf bytes.Buffer

	buf.WriteString(typ + " ")
	if len(list) > 1 {
		buf.WriteString("(\n")
	}

	buf.WriteString(strings.Join(mapStrings(list, func(s string) string { return fmt.Sprintf("%s = %s.%[1]s", s, pkg.Name) }), "\n"))

	if len(list) > 1 {
		buf.WriteString("\n)")
	}

	return buf.String()
}

func mapStrings(src []string, fn func(string) string) []string {
	dst := make([]string, len(src))
	copy(dst, src)

	for i := range src {
		dst[i] = fn(src[i])
	}

	return dst
}
